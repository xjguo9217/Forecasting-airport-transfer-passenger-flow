# This script illustrates the method of predicting distributions of passenger flows when assuming dependent passenger arrivals. Here, we use domestic flows as an example. 

# The first 41 lines are the same as those in "3. empirical distribution binomial calculation.R". Please take a look at the comments/explanations in the other file if you have any questions.
library(gtools)
library(lubridate)
library(copula)
data <- read.csv('~/Dropbox/APOC paper/code/New training and testing set/data/testingSet.csv',head = TRUE)
nn <- which(data$ob_int_dom == 'D') # for domestic
data <- data[nn,] # for domestic
leaf_no_train = read.csv('leaf_train_no.csv',head=FALSE)
leaf_no_train <- leaf_no_train[-1,]
train_data = read.csv('~/Dropbox/APOC paper/code/New training and testing set/data/trainingSet_qr.csv',head=TRUE)
leaf_testing <- read.csv('leaf_test_no.csv',head=FALSE)
leaf_testing <- leaf_testing[-1,]
leaf_testing <- leaf_testing[nn,] # for domestic
train_data <- train_data$Delta
unique_leaf_train <- unique(leaf_no_train[,2])

on_chock = as.POSIXct(strptime(data$on_chocks_time, "%Y-%m-%d %H:%M:%S"), tz = "UTC")
on_chock_date = date(on_chock)
on_chock_date_unique = unique(on_chock_date)
n1 <- length(on_chock_date_unique)
df = rep(ymd_hms(paste(on_chock_date_unique[1], '00:00:00'), tz = "UTC"),96*n1)

for (i in 1:n1) {
  df[((i-1)*96+1) : (i*96)] <- seq(ymd_hms(paste(on_chock_date_unique[i], '00:00:00'), tz = "UTC"), by = '15 min',length.out=(96))
}
df = as.POSIXct(strptime(df, "%Y-%m-%d %H:%M:%S"), tz = "UTC")

confTime = strptime(data$local_conform_time, "%Y-%m-%d %H:%M:%S", tz = "UTC")
confTime1 = with(confTime, as.POSIXct((ceiling(as.numeric(confTime)/(15*60))) * (15*60), origin = "1970-01-01", tz='UTC'))
countPax1 = rep(NA,96*length(on_chock_date_unique))
for (i in 1:length(on_chock_date_unique)) {
  this_date <- on_chock_date_unique[i]
  n <- which(on_chock_date==this_date)
  this_confTime <- confTime1[n]
  this_confTime <- c(as.POSIXct(paste(this_date,"00:00:00"), tz='UTC'), this_confTime, as.POSIXct(paste(this_date,"23:45:00"), tz='UTC'))
  countPax = data.frame(table(cut(this_confTime, breaks = "15 mins")))
  countPax$Freq[1] = countPax$Freq[1] - 1
  countPax$Freq[96] = countPax$Freq[96] - 1
  countPax1[((i-1)*96+1) : (i*96)] = countPax$Freq
}

# Read in the two files generated by runing "3. empirical distribution binomial calculation.R".
prob_p = readRDS('empirical_pdf_domestic.rds')
data_periods <- read.csv('first_last_periods_empirical_domestic.csv')

# Run copula-based simulations to produce passenger flows (# of passenger arrivals at conformance desk (immigration/security areas))
simulation_result <- matrix(0, length(df)-1, 1000)
simulation_result_dom <- matrix(0, length(df)-1, 1000)
set.seed(201)
for (i in 2:length(df)) { # for each 15 min interval
  pax_n_this_period <- which(data_periods$first <= i&data_periods$pred_last >= i) # Find passengers with positive but < 1 probability of arriving in this interval.
  p_vec <- rep(NA,length(pax_n_this_period))
  if (length(pax_n_this_period) == 0)  next
  for (j in 1:length(pax_n_this_period)) { # For each of these passengers, calculate the probability of arriving within this interval.
    p_vec[j] <- prob_p[[pax_n_this_period[j]]][i+1-data_periods$first[pax_n_this_period[j]]]
  }
  p_vec[which(p_vec < 0)] = 0
  pax_thisperiod_flight <- data$ib_flight_no[pax_n_this_period] # Find passengers' inbound flights.
  simulate_binary <- matrix(NA, 1000, length(pax_n_this_period))
  for (k in 1:length(unique(pax_thisperiod_flight))) { # for each inbound flight. We assume arrivals of passengers from the same flight are dependent with a homogenous Copula parameter. 
    pax_this_flight <- which(pax_thisperiod_flight == unique(pax_thisperiod_flight)[k]) # Find passengers on this flight.
    # Simulate arrivals using copula. See Section 3.5 in the paper for more details.
    if (length(pax_this_flight) > 1) { 
      u = rCopula(1000, normalCopula(0.4, dim = length(pax_this_flight))) #
      simulate_binary[,pax_this_flight] = qbinom(u,rep(1,length(pax_this_flight)),p_vec[pax_this_flight])
    } else {
      simulate_binary[,pax_this_flight] = rbinom(1000,1,p_vec[pax_this_flight])
    }
  }
  simulation_result[i-1,] <- rowSums(simulate_binary)
}

# The code below for calculating quantiles and pinball losses are the same as those in "3. empirical distribution binomial calculation.R". Please take a look at the comments/explanations in the other file if you have any questions.
simulation_result <- as.matrix(simulation_result)
simulation_result1 = simulation_result
simulation_result[is.na(simulation_result)] = 0
p_05 <- rep(0,length(df)-1)
p_25 <- rep(0,length(df)-1)
p_50 <- rep(0,length(df)-1)
p_75 <- rep(0,length(df)-1)
p_95 <- rep(0,length(df)-1)
p_mean <- rep(0,length(df)-1)
for (i in 1:(length(countPax1)-1)) {
  p_05[i] <- quantile(simulation_result[i,], 0.05)
  p_25[i] <- quantile(simulation_result[i,], 0.25)
  p_50[i] <- quantile(simulation_result[i,], 0.5)
  p_75[i] <- quantile(simulation_result[i,], 0.75)
  p_95[i] <- quantile(simulation_result[i,], 0.95)
  p_mean[i] <- mean(simulation_result[i,])
}
p_05 <- c(0,p_05)
p_25 <- c(0,p_25)
p_50 <- c(0,p_50)
p_75 <- c(0,p_75)
p_95 <- c(0,p_95)
p_mean <- c(0,p_mean)

countPax2 = countPax2 = read.csv('actual_flow_domestic.csv')[,1]

for (i in 1:(length(countPax1)/96-1)) {
  countPax2[((i-1)*96+89):(i*96+20)] <- NA
  p_mean[((i-1)*96+89):(i*96+20)] <- NA
  p_05[((i-1)*96+89):(i*96+20)] <- NA
  p_25[((i-1)*96+89):(i*96+20)] <- NA
  p_50[((i-1)*96+89):(i*96+20)] <- NA
  p_75[((i-1)*96+89):(i*96+20)] <- NA
  p_95[((i-1)*96+89):(i*96+20)] <- NA
}

countPax2[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA
p_mean[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA
p_05[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA
p_25[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA
p_50[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA
p_75[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA
p_95[((length(countPax1)/96-1)*96+89):length(countPax1)] <- NA

countPax2[1:20] <- NA
p_mean[1:20] <- NA
p_05[1:20] <- NA
p_25[1:20] <- NA
p_50[1:20] <- NA
p_75[1:20] <- NA
p_95[1:20] <- NA

countPax2 = na.omit(countPax2)
p_mean = na.omit(p_mean)
p_05 = na.omit(p_05)
p_25 = na.omit(p_25)
p_50 = na.omit(p_50)
p_75 = na.omit(p_75)
p_95 = na.omit(p_95)

pinball <- function(pred, act, q) {
  I = 1*(act>pred)
  l <- (act - pred)*q*I + (pred - act)*(1-q)*(1-I)
  return(mean(l))
}

c(pinball(p_05, countPax2, 0.05),
  pinball(p_25, countPax2, 0.25),
  pinball(p_50, countPax2, 0.50),
  pinball(p_75, countPax2, 0.75),
  pinball(p_95, countPax2, 0.95))
